/* This file is part of Zenroom (https://zenroom.dyne.org)
 *
 * Copyright (C) 2017-2020 Dyne.org foundation
 * designed, written and maintained by Alberto Lerda <albertolerda97@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */



#include <zenroom.h>
#include <zen_error.h>
#include <lua_functions.h>
#include <zen_octet.h>
#include <ed25519.h>
#include <randombytes.h>

#define ASSERT_OCT_LEN(OCT, TYPE, MSG)\
	if((OCT)->len != sizeof(TYPE)) { \
		failed_msg = (MSG);\
		lua_pushnil(L);\
		goto end;\
	}

#define PUSH_CHECK_OCT_LEN(OCT, TYPE)\
	lua_pushboolean(L, ((OCT)->len == sizeof(TYPE))):


/// <h1>Ed25519 signature scheme (ED)</h1>
// This module provides algorithms and functions for an elliptic curve signature scheme. It uses the Elliptic Curve Ed25519. Ed25519 is an elliptic curve used in elliptic-curve cryptography (ECC) designed for use with the Elliptic-curve Diffieâ€“Hellman (ECDH) key agreement scheme.
// It is based on asymmetric public/private key encryption technologies.
//
//
// Public key size = 256 bit (64 byte),
//
// Secret key size = 256 bit (64 byte),
//
// Sign size = 512 bit (128 byte) provided by the hash function SHA-512
// @module ED



/// ED Functions
// @section ED


/***
Generate a secret key for the digital signature based on the Elliptic Curve Ed25519.
Does not require an input. 
@function ED.secgen
	@return sk, an octet of 64 bytes 
	@usage
	ED = require("ed")
	sk = ED.secgen()
	print(sk:hex())		-- print the secret key in hexadecimal notation

 */

static int ed_secgen(lua_State *L) {
	BEGIN();
	Z(L);
	register const size_t sksize = sizeof(ed25519_secret_key);
	octet *sk = o_new(L, sksize);
	if(!sk) {
		THROW("Could not allocate secret key");
	} else {
		register size_t i;
		for(i=0; i < sksize; i++)
		  sk->val[i] = RAND_byte(Z->random_generator);
		sk->len = sksize;
	}
	END(1);
}

/***
 Deterministic algorithm that generates a public key for the digital signature based on the Elliptic Curve Ed25519.
 @function ED.pubgen
 @param sk, required a secret key generated by the previous function
 @return pk, an octet of 64 bytes 
 @usage
 ED = require("ed")
 sk = ED.secgen()
 pk = ED.pubgen(sk)
 print(pk:hex())			-- print the public key in hexadecimal notation

 */

static int ed_pubgen(lua_State *L) {
	BEGIN();
	char *failed_msg = NULL;
	octet *pk = NULL, *sk = NULL;
	sk = o_arg(L, 1);
	if(!sk) {
		failed_msg = "Could not allocate secret key";
		goto end;
	}

	ASSERT_OCT_LEN(sk, ed25519_secret_key, "Invalid size for EdDSA secret key")

	pk = o_new(L, sizeof(ed25519_public_key));
	if(!pk) {
		failed_msg = "Could not allocate public key";
		goto end;
	}
	pk->len = sizeof(ed25519_public_key);

	ed25519_publickey((unsigned char*)sk->val, (unsigned char *)pk->val);
end:
	o_free(L, sk);
	if(failed_msg != NULL) {
		THROW(failed_msg);
	}
	END(1);
}

/***
 Sign a message m using a secret key sk generated by ED.secgen().
 @function ED.sign
 @param sk
 @param m
 @return an octet of 128 bytes, the digital signature
 @usage
 ED = require("ed")
 random_message_length = 1
 m = OCTET.new(random_message_length)
 sk = ED.secgen()
 sign = ED.sign(sk,m)
 print(sign:hex())

 */


static int ed_sign(lua_State *L) {
	BEGIN();
	char *failed_msg = NULL;
	octet *sk = NULL, *m = NULL, *sig = NULL;
	sk = o_arg(L, 1);
	if(!sk) {
		failed_msg = "Could not allocate secret key";
		goto end;
	}
	m = o_arg(L, 2);
	if(!m) {
		failed_msg = "Could not allocate message";
		goto end;
	}

	ASSERT_OCT_LEN(sk, ed25519_secret_key, "Invalid size for EdDSA secret key")

	ed25519_public_key pk;
	ed25519_publickey((unsigned char*)sk->val, pk);

	sig = o_new(L, sizeof(ed25519_signature));
	if(!sig) {
		failed_msg = "Could not allocate signature";
		goto end;
	}
	sig->len = sizeof(ed25519_signature);

	ed25519_sign((unsigned char*)m->val, m->len,
		     (unsigned char*)sk->val, pk,
		     (unsigned char*)sig->val);

end:
	o_free(L, m);
	o_free(L, sk);
	if(failed_msg != NULL) {
		THROW(failed_msg);
	}
	END(1);
}

/***
 Verify if the signature (sign) of a message (m) is correct.
 @function ED.verify
 @param pk
 @param sign
 @param m
 @return a boolean: true if the signature is correct, false otherwise 
 
@usage
random_message_length = 1
m = OCTET.new(random_message_length)
sk = ED.secgen()
pk = ED.pubgen(sk)
sign = ED.sign(sk,m)
bool = ED.verify(pk, sign, m)
if bool then print("true")
else print("false")
end
*/

static int ed_verify(lua_State *L) {
	BEGIN();
	char *failed_msg = NULL;
	octet *pk = NULL, *sig = NULL, *m = NULL;
	pk = o_arg(L, 1);
	if(!pk) {
		failed_msg = "Could not allocate public key";
		goto end;
	}
	sig = o_arg(L, 2);
	if(!sig) {
		failed_msg = "Could not allocate signature";
		goto end;
	}
	m = o_arg(L, 3);
	if(!m) {
		failed_msg = "Could not allocate message";
		goto end;
	}

	ASSERT_OCT_LEN(pk, ed25519_public_key, "Invalid size for EdDSA public key")
	ASSERT_OCT_LEN(sig, ed25519_signature, "Invalid size for EdDSA signature")

	lua_pushboolean(L, ed25519_sign_open((unsigned char*)m->val, m->len,
				             (unsigned char*)pk->val,
					     (unsigned char*)sig->val) == 0);

end:
	o_free(L, m);
	o_free(L, pk);
	o_free(L, sig);
	if(failed_msg != NULL) {
		THROW(failed_msg);
	}
	END(1);
}

int luaopen_ed(lua_State *L) {
	(void)L;
	const struct luaL_Reg ed_class[] = {
		{"secgen", ed_secgen},
		{"keygen", ed_secgen},
		{"pubgen", ed_pubgen},
		{"sign", ed_sign},
		{"verify", ed_verify},
		{NULL,NULL}
	};
	const struct luaL_Reg ed_methods[] = {
		{NULL,NULL}
	};

	zen_add_class(L, "ed", ed_class, ed_methods);
	return 1;
}
